diff --git a/.DS_Store b/.DS_Store
index 4c0513c..ad3fedd 100644
Binary files a/.DS_Store and b/.DS_Store differ
diff --git a/.idea/deployment.xml b/.idea/deployment.xml
index 19b4bf8..3db731f 100644
--- a/.idea/deployment.xml
+++ b/.idea/deployment.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="PublishConfigData" serverName="ren" remoteFilesAllowedToDisappearOnAutoupload="false" />
+  <component name="PublishConfigData" autoUpload="Always" remoteFilesAllowedToDisappearOnAutoupload="false">
+    <option name="myAutoUpload" value="ALWAYS" />
+  </component>
 </project>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
index dda9dc6..9cad23a 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7 (deeplearning)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.6 (tf)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
diff --git a/.idea/py_paraverifier.iml b/.idea/py_paraverifier.iml
index b91c30b..a1a8f18 100644
--- a/.idea/py_paraverifier.iml
+++ b/.idea/py_paraverifier.iml
@@ -2,12 +2,13 @@
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
     <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.7 (deeplearning)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.6 (tf)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="PyDocumentationSettings">
     <option name="format" value="PLAIN" />
     <option name="myDocStringFormat" value="Plain" />
+    <option name="renderExternalDocumentation" value="true" />
   </component>
   <component name="TestRunnerService">
     <option name="PROJECT_TEST_RUNNER" value="pytest" />
diff --git a/Protocol/german.m b/Protocol/german.m
index 7816ea3..e90db41 100644
--- a/Protocol/german.m
+++ b/Protocol/german.m
@@ -1,5 +1,4 @@
 const
-
   NODE_NUM : 5;
   DATA_NUM : 2;
 
diff --git a/Protocol/mutual.m b/Protocol/mutual.m
index e9a026d..76092e2 100644
--- a/Protocol/mutual.m
+++ b/Protocol/mutual.m
@@ -1,5 +1,5 @@
-const clientNUMS : 5;
-type state : enum{I, T, C, E};
+const clientNUMS : 3;
+type state : enum{idle, try, crit, exit};
 
      client: 1..clientNUMS;
 
@@ -8,32 +8,32 @@ var n : array [client] of state;
     x : boolean;
 
 ruleset i : client do
-rule "Try" n[i] = I ==> begin
-      n[i] := T;end;
+rule "Try" n[i] = idle ==> begin
+      n[i] := try;end;
 
 rule "Crit"
-      n[i] = T& x = true ==>begin
-      n[i] := C; x := false; end;
+      n[i] = try& x = true ==>begin
+      n[i] := crit; x := false; end;
 
 rule "Exit"
-      n[i] = C ==>begin
-      n[i] := E;end;
+      n[i] = crit ==>begin
+      n[i] := exit;end;
 
 
 rule "Idle"
-      n[i] = E ==> begin n[i] := I;
+      n[i] = exit & x = false ==> begin n[i] := idle;
       x := true;end;
 endruleset;
 
 startstate
 begin
  for i: client do
-    n[i] := I;
+    n[i] := idle;
     x := true;
   endfor;
 endstartstate;
 
 ruleset i:client; j: client do
 invariant "coherence"
- ! (n[i] = C & n[j] = C)
+ ! (n[i] = crit & n[j] = crit)
 endruleset;
diff --git a/Protocol/n_mutual.json b/Protocol/n_mutual.json
index a3c2da1..70bca5b 100644
--- a/Protocol/n_mutual.json
+++ b/Protocol/n_mutual.json
@@ -5,16 +5,16 @@
         "x": "bool"
     },
     "states": [
-        "I",
-        "T",
-        "C",
-        "E"
+        "idle",
+        "try",
+        "crit",
+        "exit"
     ],
     "init": {
         "var": [
             "i"
         ],
-        "guard": "n i  = I & x = true"
+        "guard": "n i  = idle & x = true"
     },
     "rules": [
         {
@@ -22,9 +22,9 @@
             "var": [
                 "i"
             ],
-            "guard": "n i  = I",
+            "guard": "n i  = idle",
             "assign": {
-                "n i ": "T"
+                "n i ": "try"
             }
         },
         {
@@ -32,9 +32,9 @@
             "var": [
                 "i"
             ],
-            "guard": "n i  = T & x = true",
+            "guard": "n i  = try & x = true",
             "assign": {
-                "n i ": "C",
+                "n i ": "crit",
                 "x": "false"
             }
         },
@@ -43,9 +43,9 @@
             "var": [
                 "i"
             ],
-            "guard": "n i  = C",
+            "guard": "n i  = crit",
             "assign": {
-                "n i ": "E"
+                "n i ": "exit"
             }
         },
         {
@@ -53,9 +53,9 @@
             "var": [
                 "i"
             ],
-            "guard": "n i  = E & x = false",
+            "guard": "n i  = exit & x = false",
             "assign": {
-                "n i ": "I",
+                "n i ": "idle",
                 "x": "true"
             }
         }
@@ -66,7 +66,7 @@
                 "i",
                 "j"
             ],
-            "prop": "~ (n i  = C & n j  = C)"
+            "prop": "~ (n i  = crit & n j  = crit)"
         }
     ]
 }
\ No newline at end of file
diff --git a/Protocol/n_mutual.smv b/Protocol/n_mutual.smv
index 078f9e3..369852d 100644
--- a/Protocol/n_mutual.smv
+++ b/Protocol/n_mutual.smv
@@ -1,8 +1,8 @@
 MODULE main
 VAR
-n[1] : {i, t, c, e};
-n[2] : {i, t, c, e};
-n[3] : {i, t, c, e};
+n[1] : {idle, try, crit, exit};
+n[2] : {idle, try, crit, exit};
+n[3] : {idle, try, crit, exit};
 x : boolean;
 
 --------------------
@@ -35,13 +35,13 @@ n_Idle__3 : process Proc__n_Idle__3(n[3], x);
 
 ASSIGN
 init(n[1]) := case
-TRUE : i;
+TRUE : idle;
 esac;
 init(n[2]) := case
-TRUE : i;
+TRUE : idle;
 esac;
 init(n[3]) := case
-TRUE : i;
+TRUE : idle;
 esac;
 init(x) := case
 TRUE : TRUE;
@@ -56,7 +56,7 @@ esac;
 MODULE Proc__n_Try__1(n__1)
 ASSIGN
 next(n__1) := case
-(n__1 = i) : t;
+(n__1 = idle) : try;
 TRUE : n__1;
 esac;
 
@@ -65,7 +65,7 @@ esac;
 MODULE Proc__n_Try__2(n__2)
 ASSIGN
 next(n__2) := case
-(n__2 = i) : t;
+(n__2 = idle) : try;
 TRUE : n__2;
 esac;
 
@@ -74,7 +74,7 @@ esac;
 MODULE Proc__n_Try__3(n__3)
 ASSIGN
 next(n__3) := case
-(n__3 = i) : t;
+(n__3 = idle) : try;
 TRUE : n__3;
 esac;
 
@@ -83,11 +83,11 @@ esac;
 MODULE Proc__n_Crit__1(n__1, x)
 ASSIGN
 next(n__1) := case
-((n__1 = t) & (x = TRUE)) : c;
+((n__1 = try) & (x = TRUE)) : crit;
 TRUE : n__1;
 esac;
 next(x) := case
-((n__1 = t) & (x = TRUE)) : FALSE;
+((n__1 = try) & (x = TRUE)) : FALSE;
 TRUE : x;
 esac;
 
@@ -96,11 +96,11 @@ esac;
 MODULE Proc__n_Crit__2(n__2, x)
 ASSIGN
 next(n__2) := case
-((n__2 = t) & (x = TRUE)) : c;
+((n__2 = try) & (x = TRUE)) : crit;
 TRUE : n__2;
 esac;
 next(x) := case
-((n__2 = t) & (x = TRUE)) : FALSE;
+((n__2 = try) & (x = TRUE)) : FALSE;
 TRUE : x;
 esac;
 
@@ -109,11 +109,11 @@ esac;
 MODULE Proc__n_Crit__3(n__3, x)
 ASSIGN
 next(n__3) := case
-((n__3 = t) & (x = TRUE)) : c;
+((n__3 = try) & (x = TRUE)) : crit;
 TRUE : n__3;
 esac;
 next(x) := case
-((n__3 = t) & (x = TRUE)) : FALSE;
+((n__3 = try) & (x = TRUE)) : FALSE;
 TRUE : x;
 esac;
 
@@ -122,7 +122,7 @@ esac;
 MODULE Proc__n_Exit__1(n__1)
 ASSIGN
 next(n__1) := case
-(n__1 = c) : e;
+(n__1 = crit) : exit;
 TRUE : n__1;
 esac;
 
@@ -131,7 +131,7 @@ esac;
 MODULE Proc__n_Exit__2(n__2)
 ASSIGN
 next(n__2) := case
-(n__2 = c) : e;
+(n__2 = crit) : exit;
 TRUE : n__2;
 esac;
 
@@ -140,7 +140,7 @@ esac;
 MODULE Proc__n_Exit__3(n__3)
 ASSIGN
 next(n__3) := case
-(n__3 = c) : e;
+(n__3 = crit) : exit;
 TRUE : n__3;
 esac;
 
@@ -149,11 +149,11 @@ esac;
 MODULE Proc__n_Idle__1(n__1, x)
 ASSIGN
 next(n__1) := case
-(n__1 = e) : i;
+(n__1 = exit) : idle;
 TRUE : n__1;
 esac;
 next(x) := case
-(n__1 = e) : TRUE;
+(n__1 = exit) : TRUE;
 TRUE : x;
 esac;
 
@@ -162,11 +162,11 @@ esac;
 MODULE Proc__n_Idle__2(n__2, x)
 ASSIGN
 next(n__2) := case
-(n__2 = e) : i;
+(n__2 = exit) : idle;
 TRUE : n__2;
 esac;
 next(x) := case
-(n__2 = e) : TRUE;
+(n__2 = exit) : TRUE;
 TRUE : x;
 esac;
 
@@ -175,10 +175,10 @@ esac;
 MODULE Proc__n_Idle__3(n__3, x)
 ASSIGN
 next(n__3) := case
-(n__3 = e) : i;
+(n__3 = exit) : idle;
 TRUE : n__3;
 esac;
 next(x) := case
-(n__3 = e) : TRUE;
+(n__3 = exit) : TRUE;
 TRUE : x;
 esac;
\ No newline at end of file
diff --git a/RN/CartPole-v0.py b/RN/CartPole-v0.py
index f423680..58eccdc 100644
--- a/RN/CartPole-v0.py
+++ b/RN/CartPole-v0.py
@@ -1,14 +1,17 @@
 import gym
-env = gym.make('CartPole-v0')
-print(env.action_space)
-for i_episode in range(20):
+# env = gym.make('CartPole-v0')
+env = gym.make('FormulaEnv-v0', filename='../Protocol/n_mutual.json')
+
+# print(env.action_space)
+for i_episode in range(1):
     observation = env.reset()
+    print(observation)
     for t in range(100):
-        env.render()
-        print(observation)
+        # env.render()
+        # print(observation)
         action = env.action_space.sample()
         observation, reward, done, info = env.step(action)
         if done:
             print("Episode finished after {} timesteps".format(t+1))
             break
-env.close()
\ No newline at end of file
+env.close()
diff --git a/RN/MountainCar-v0.py b/RN/MountainCar-v0.py
deleted file mode 100644
index cd2ab20..0000000
--- a/RN/MountainCar-v0.py
+++ /dev/null
@@ -1,13 +0,0 @@
-import gym
-env = gym.make('MountainCar-v0')
-for i_episode in range(20):
-    observation = env.reset()
-    for t in range(100):
-        env.render()
-        print(observation)
-        action = env.action_space.sample()
-        observation, reward, done, info = env.step(action)
-    if done:
-        print("Episode finished after {} timesteps".format(t+1))
-        break
-env.close()
\ No newline at end of file
diff --git a/RN/__init__.py b/RN/__init__.py
index 332726d..7275f16 100644
--- a/RN/__init__.py
+++ b/RN/__init__.py
@@ -1 +1 @@
-from FormulaEnv import *
+# from FormulaEnv import *
diff --git a/RN/__pycache__/FormulaEnv.cpython-36.pyc b/RN/__pycache__/FormulaEnv.cpython-36.pyc
deleted file mode 100644
index 83e2c28..0000000
Binary files a/RN/__pycache__/FormulaEnv.cpython-36.pyc and /dev/null differ
diff --git a/RN/__pycache__/FormulaEnv.cpython-37.pyc b/RN/__pycache__/FormulaEnv.cpython-37.pyc
deleted file mode 100644
index 57338ba..0000000
Binary files a/RN/__pycache__/FormulaEnv.cpython-37.pyc and /dev/null differ
diff --git a/RN/gymtest1.py b/RN/gymtest1.py
deleted file mode 100644
index 67a7376..0000000
--- a/RN/gymtest1.py
+++ /dev/null
@@ -1,7 +0,0 @@
-import gym  # 导入包
-env = gym.make('CartPole-v0') # 构建一个名字叫“CartPole-v0”的Gym场景
-env.reset() # 初始化场景
-for _ in range(200): #
-    env.render()  # 画出当前场景情况
-    env.step(env.action_space.sample()) # 给环境中Agent一次命令，并让环境演化一步
-env.close()  # 关闭环境
\ No newline at end of file
diff --git a/RN/gymtest2.py b/RN/gymtest2.py
deleted file mode 100644
index 0e4e29e..0000000
--- a/RN/gymtest2.py
+++ /dev/null
@@ -1,13 +0,0 @@
-import gym
-env = gym.make('CartPole-v0')
-for i_episode in range(20):
-    observation = env.reset()  # 得到环境给出的初始反馈
-    for t in range(100):
-        env.render()
-        print('ob:', observation)
-        action = env.action_space.sample()  # 产生一个允许范围内的随机行动
-        observation, reward, done, info = env.step(action) # 得到该次行动的反馈
-        if done:
-            print("Episode finished after {} timesteps".format(t+1))
-            break
-env.close()
\ No newline at end of file
diff --git a/RN/run_ppo.py b/RN/run_ppo.py
index e69de29..5ece41c 100644
--- a/RN/run_ppo.py
+++ b/RN/run_ppo.py
@@ -0,0 +1,49 @@
+import gym
+
+from tf2rl.algos.ppo import PPO
+from tf2rl.experiments.on_policy_trainer import OnPolicyTrainer
+from tf2rl.envs.utils import is_discrete, get_act_dim
+
+
+if __name__ == '__main__':
+    parser = OnPolicyTrainer.get_argument()
+    parser = PPO.get_argument(parser)
+    parser.add_argument('--env-name', type=str,
+                        default="Pendulum-v0")
+    parser.set_defaults(test_interval=20480)
+    parser.set_defaults(save_summary_interval=20480)
+    parser.set_defaults(max_steps=int(2e6))
+    parser.set_defaults(horizon=2048)
+    parser.set_defaults(batch_size=64)
+    parser.set_defaults(gpu=-1)
+    args = parser.parse_args()
+
+    env = gym.make(args.env_name, filename='../Protocol/n_mutual.json')
+    test_env = gym.make(args.env_name, filename='../Protocol/n_mutual.json')
+
+    policy = PPO(
+        state_shape=env.observation_space.shape,
+        action_dim=get_act_dim(env.action_space),
+        is_discrete=is_discrete(env.action_space),
+        max_action=None if is_discrete(
+            env.action_space) else env.action_space.high[0],
+        batch_size=args.batch_size,
+        actor_units=(64, 64),
+        critic_units=(64, 64),
+        n_epoch=10,
+        lr_actor=3e-4,
+        lr_critic=3e-4,
+        hidden_activation_actor="tanh",
+        hidden_activation_critic="tanh",
+        discount=0.99,
+        lam=0.95,
+        entropy_coef=0.,
+        horizon=args.horizon,
+        normalize_adv=args.normalize_adv,
+        enable_gae=args.enable_gae,
+        gpu=args.gpu)
+    trainer = OnPolicyTrainer(policy, env, args, test_env=test_env)
+    if args.evaluate:
+        trainer.evaluate_policy_continuously()
+    else:
+        trainer()
\ No newline at end of file
diff --git a/Utils/InvHold.py b/Utils/InvHold.py
index 77a3f73..9f24c41 100644
--- a/Utils/InvHold.py
+++ b/Utils/InvHold.py
@@ -1,8 +1,9 @@
 #author: Hongjian Jiang
 
 
-from type import *
-from smt2 import *
+from gym.utils.type import *
+from gym.utils.smt2 import *
+from gym.utils.type import Var
 import re
 
 
@@ -12,8 +13,22 @@ def weakestprecondition(statement, formula):
     :param formula: given invariant formula
     :return: the string of the weakest precondtion
     '''
+    # print('f:', formula, 's:', statement)
     varsInformula = formula.getVars()
+    if '(' in str(formula):
+        innform = re.findall(r'\((.*?)\)', str(formula), re.S)[0]
+    else:
+        innform = re.findall(r'~(.*)', str(formula), re.S)[0]
+    varlist = []
+    valuelist = []
+    templist = innform.split('&')
+    for i in templist:
+        str1 = re.findall(r'(.*?)=', i, re.S)[0]
+        str2 = re.findall(r'=(.*)', i, re.S)[0]
+        varlist.append(str1.strip())
+        valuelist.append(str2.strip())
     if statement.isAssign():        #single assign condition
+        # print(statement,formula)
         var = statement.getVar()
         exp = statement.getExp()
         if not str(var) in varsInformula: #assignment has no affection on formula
@@ -25,10 +40,19 @@ def weakestprecondition(statement, formula):
         exps = statement.getExps()
         resultFormula = str(formula)
         for i,v in enumerate(vars):
-            if v in varsInformula:
+            if v in varlist:
+                varlist[varlist.index(v)] = exps[i]
                 resultFormula = resultFormula.replace(v,exps[i])
             else:
                 pass
+        resultFormula = '~('
+        for i in range(len(varlist)):
+            if i != len(varlist)-1:
+                resultFormula += varlist[i]+ '='+valuelist[i] +' & '
+            else:
+                resultFormula += varlist[i]+ '='+valuelist[i]
+        resultFormula+=')'
+    # print('test:', 'statement:',statement, 'formula:',formula, 'result:', resultFormula)
     return resultFormula
 
 
@@ -73,9 +97,9 @@ def invHoldForCondition3(guard, formula):
 
 
 if __name__ == '__main__':
-    statement = SAssign(EVar(Var("n"),'j'),EConst(Var("I")))
+    statement = SAssign(EVar(Var("n"),'j'),EConst(Var("exit")))
     statement1 = SAssign(EConst(Strc("x")),FChaos())
-    formula = FNeg(FAndlist([FEqn(EVar(Var("n"),'i'),EConst(Strc("C"))),FEqn(EConst(Strc("x")),EConst(Boolc("True")))]))
+    formula = FNeg(FAndlist([FEqn(EVar(Var("n"),'i'),EConst(Strc("exit"))),FEqn(EVar(Var("n"),'j'),EConst(Strc("exit"))),FEqn(EConst(Strc("x")),EConst(Boolc("False")))]))
     statement2 = SParallel([statement, statement1])
     wp = weakestprecondition(statement2,formula)
     # print(invHoldForCondition3(FEqn(EVar(Var("n"),"j"),EConst(Strc("E")))),wp)
\ No newline at end of file
diff --git a/Utils/Paraverifier.py b/Utils/Paraverifier.py
index 3bfbcd8..c1ea7a3 100644
--- a/Utils/Paraverifier.py
+++ b/Utils/Paraverifier.py
@@ -1,9 +1,9 @@
 # Author: Hongjian Jiang
 
 import os
-from invHold import *
-from parse import *
-from smt2 import *
+from Utils.invHold import *
+from Utils.parse import *
+from Utils.smt2 import *
 import json
 import os
 import numpy as np
@@ -13,7 +13,6 @@ file = '../Protocol/n_mutual.json'
 def load_system(filename):
     dn = os.path.dirname(os.getcwd())
     with open(os.path.join(dn, 'Protocol/' + filename), encoding='utf-8') as a:
-    # with open(filename, encoding='utf-8') as a:
         data = json.load(a)
     name = data['name']
     vars = []
@@ -31,7 +30,22 @@ def load_system(filename):
         for new in T.getArgs()[0]:
             for r in data['rules']:
                 r['var'] = str(r['var']).replace("i", new)
-                r['guard'] = str(r['guard']).replace("i", new)
+                guard = str(r['guard'])
+                templist1 = guard.split('&')
+                varlist = []
+                valuelist = []
+                for i in templist1:
+                    varlist.append(re.findall(r'(.*?)\s*=', i, re.S)[0].strip())
+                    valuelist.append(re.findall(r'=\s*(.*)', i, re.S)[0].strip())
+                for i in varlist:
+                    varlist[varlist.index(i)] = varlist[varlist.index(i)].replace('i', new)
+                guardStr = ''
+                for i in range(len(varlist)):
+                    if i != len(varlist)-1:
+                        guardStr += varlist[i] + ' = ' + valuelist[i] + ' & '
+                    else:
+                        guardStr += varlist[i] + ' = ' + valuelist[i]
+                r['guard'] = guardStr
                 for k in r['assign'].keys():
                     if 'i' in k and new != 'i':
                         new1 = str(k).replace("i", new)
@@ -39,17 +53,6 @@ def load_system(filename):
                         del r['assign'][k]
                 T1 = parse_rule(str(r))
                 rules.append(T1)
-
-        # for r in data['rules']:
-        #     r['var'] = str(r['var']).replace(T.getArgs()[0][-1], "k")
-        #     r['guard'] = str(r['guard']).replace(T.getArgs()[0][-1], "k")
-        #     for k in r['assign'].keys():
-        #         if T.getArgs()[0][-1] in k:
-        #             new1 = str(k).replace(T.getArgs()[0][-1], "k")
-        #             r['assign'][new1] = r['assign'][k]
-        #             del r['assign'][k]
-        #     T2 = parse_rule(str(r))
-        #     rules.append(T2)
     inits = []
     init = data['init']
     T = parse_init(str(init))
@@ -75,12 +78,12 @@ class ParaSystem():
         self.init = init
         self.invForm = []
         self.allinvs = [] # store the whole invariant formula
-        self.foundedinvs = [] # store the founded invariant formula
         self.relation = {}
         self.smt2 = SMT2(file)
         self.search_flag = dict()
         self.add_invariant_prop()
         self.search_invariant1()
+        self.mapping = []
         # var_map used in gcl library
         self.var_map = dict()
         for i, v in enumerate(self.vars):
@@ -130,57 +133,28 @@ class ParaSystem():
             self.search_flag[str(formula)] = False
         return self.allinvs
 
-    # def search_invariant(self):
-    #     '''
-    #     :return: the founed invariant
-    #     '''
-    #     newInv = []
-    #     for inv in self.invs:
-    #         for r in self.rules:
-    #             statement = r.getStatement()
-    #             if invHoldCondition(statement, inv.getInv(), file) == 3: #inv.getInv()
-    #                 if invHoldForCondition3(r.getGuard(), weakestprecondition(statement, inv.getInv())) not in newInv:
-    #                     newStr = invHoldForCondition3(r.getGuard(), weakestprecondition(statement, inv.getInv()))
-    #                     temp = self.smt2.getStringInFormula(newStr).replace('(','').replace(')','')
-    #                     print('tp',temp)
-    #                     formula_list = temp.split('&')
-    #                     list1 = []
-    #                     print('fs:', formula_list)
-    #                     for f in formula_list:
-    #                         if self.smt2.getEqualFirst(f).strip() != self.smt2.getEqualSecond(f).strip():
-    #                             list1.append(f.strip())
-    #                     newStr = '~('+" & ".join(list1)+')'
-    #                     newInv.append(newStr)
-    #                     if newStr not in self.foundedinvs:
-    #                         self.foundedinvs.append(newStr)
-    #                     if newStr not in self.allinvs:
-    #                         self.allinvs.append(newStr)
-    #         self.relation[str(inv.getInv())] = newInv
-    #
-    #     return newInv
-
     def search_invariant1(self):
         '''
         :return: the founed invariant
         '''
-        # print(self.allinvs)
+        relation = {}
         if os.path.exists('../Data/'+self.name + '_data.json'):
             with open('../Data/'+self.name + '_data.json', 'r', encoding='utf8') as fp:
                 fp = json.load(fp)
                 self.relation = fp['relation']
                 self.allinvs = fp['allinvs']
-                self.foundedinvs = fp['foundedinvs']
         else:
-            for inv in self.allinvs:#self.invs:
+            for inv in self.allinvs:
+                #self.invs:
                 if self.search_flag[inv]:
                     continue
                 else:
-                    # print('inv has not been explored..')
                     newInv = []
                     for r in self.rules:
                         statement = r.getStatement()
                         if invHoldCondition(statement, parse_form(inv), file) == 3: #inv.getInv()
                             newStr = invHoldForCondition3(r.getGuard(), weakestprecondition(statement, parse_form(inv)))
+                            print('new:',newStr,'---->',r.getGuard(),'---->',weakestprecondition(statement, parse_form(inv)))
                             if newStr not in newInv:
                                 temp = self.smt2.getStringInFormula(newStr).replace('(','').replace(')','')
                                 formula_list = temp.split('&')
@@ -189,18 +163,22 @@ class ParaSystem():
                                     if self.smt2.getEqualFirst(f).strip() != self.smt2.getEqualSecond(f).strip():
                                         list1.append(f.strip())
                                 newStr = '~('+" & ".join(list1)+')'
-                                newInv.append(newStr)
-                                if newStr not in self.foundedinvs:
-                                    self.foundedinvs.append(newStr)
-                                if newStr not in self.allinvs:
-                                    self.allinvs.append(newStr)
-                                    self.search_flag[newStr] = False
-                    self.relation[inv] = newInv
-                    # newInv = []
-                    self.search_flag[inv] = True
-                # for key, value in self.relation.items():
-                print(len(self.relation))
-            dict = {'relation': self.relation, 'allinvs' : self.allinvs, 'foundedinvs' : self.foundedinvs}
+                                if newInv == []:
+                                    newInv.append(newStr)
+                                else:
+                                    for i in newInv:
+                                        if not self.judgeExistSameFormula(i, newStr):
+                                            newInv.append(newStr)
+                    for f in newInv:
+                        str1 = self.normalize(f)
+                        if str1 not in self.allinvs.copy():
+                            self.allinvs.append(str1)
+                            self.search_flag[str1] = False
+                relation[inv] = newInv
+            self.allinvs = self.removeSamePatInList(self.allinvs)
+            for i in self.allinvs:
+                self.relation[i] = relation[i]
+            dict = {'relation': self.relation, 'allinvs': self.allinvs}
             jsObj = json.dumps(dict)
             fileObject = open('../Data/'+self.name+ '_data.json', 'w')
             fileObject.write(jsObj)
@@ -218,18 +196,20 @@ class ParaSystem():
                 if invHoldForCondition3(r.getGuard(), weakestprecondition(statement, parse_form(form))) not in newInv:
                     newStr = invHoldForCondition3(r.getGuard(), weakestprecondition(statement, parse_form(form)))
                     temp = self.smt2.getStringInFormula(newStr)
+                    temp = temp.replace('(', '').replace(')', '')
                     formula_list = temp.split('&')
                     list1 = []
-                    for f in formula_list:
+                    for f in list(set(formula_list)):
                         if self.smt2.getEqualFirst(f).strip() != self.smt2.getEqualSecond(f).strip():
                             list1.append(f.strip())
-                    newStr = '~(' + " & ".join(list1) + ')'
-                    newInv.append(newStr)
-                    if newStr not in self.foundedinvs:
-                        self.foundedinvs.append(newStr)
-                    if newStr not in self.allinvs:
-                        self.allinvs.append(newStr)
-        self.relation[form] = newInv
+
+                    newStr = '~'+'('+" & ".join(list(set(list1))).replace('(', '').replace(')', '')+')'
+                    if not newInv and not self.judgeTrueOfForm(newStr):
+                        newInv.append(newStr)
+                    else:
+                        for i in newInv:
+                            if not self.judgeExistSameFormula(i, newStr) and not self.judgeTrueOfForm(newStr):
+                                newInv.append(newStr)
         return newInv
 
     def judgeInv(self, inv):
@@ -246,7 +226,7 @@ class ParaSystem():
                 cinv3 = cinv3 + 1
         return (cinv1, cinv3)
 
-    def judgeGuard2Formula(self,inv):
+    def judgeGuard2Formula(self, inv):
         '''
         :param inv:
         :return: the result that the guard can imply the inv formula
@@ -267,29 +247,30 @@ class ParaSystem():
                 for i in fl:
                     if i not in gl:
                         flag = True
-                if flag == False:
+                if not flag:
                     return True
         return False
 
-    def initSatInv(self,inv):
+    def initSatInv(self, inv):
         str_init = ''
         for i in self.init:
             str_init += ' & ' + (i.getFormula().replace('(','').replace(')',''))
-        # print('~('+self.smt2.getStringInFormula(inv) + str_init+')')
         return self.smt2.check('~('+self.smt2.getStringInFormula(inv) + str_init+')')
 
-
     def transform2onehot(self, formula):
-        str1 = re.findall(r'~\((.*)\)',formula,re.S)[0]
+        str1 = re.findall(r'~\((.*)\)', formula, re.S)[0]
         slen = len(self.states)*2 + 2
         list1 = []
         for i in self.states:
             str = 'n i='+i
             list1.append(str)
+            self.mapping.append(str)
         for i in self.states:
             str = 'n j='+i
             list1.append(str)
+            self.mapping.append(str)
         list1.append('x=True')
+        self.mapping.append('x=True')
         list1.append('x=False')
         slist = str1.split('&')
         temp = []
@@ -303,28 +284,247 @@ class ParaSystem():
             n[i] = 1
         return n
 
+    def transformlist2onehot(self,list):
+        l = []
+        for i in list:
+            l.append(self.transform2onehot(i))
+        return np.asarray(l)
+
+    def converhot2list(self,np):
+        rlist = []
+        for i in np.astype(int):
+            list = []
+            for j in range(len(i)):
+                if i[j] == 1:
+                    list.append(self.mapping[j])
+            str = '~('+' & '.join(list)+')'
+            rlist.append(str)
+        return rlist
+
+    def judgeExistSameFormula(self, form1, form2):
+        str1 = re.findall(r'~\((.*)\)', form1, re.S)[0]
+        str2 = re.findall(r'~\((.*)\)', form2, re.S)[0]
+        list1 = str1.split('&')
+        list2 = str2.split('&')
+        flist1 = []
+        flist2 = []
+        for i in list1:
+            flist1.append(i.strip())
+        for j in list2:
+            flist2.append(j.strip())
+        if len(flist1) != len(flist2):
+            return False
+        else:
+            x1 = set()
+            y1 = set()
+            x2 = set()
+            y2 = set()
+            for i in range(len(flist1)):
+                pre1 = re.findall(r'(.*)\=',flist1[i],re.S)[0]
+                cons1 = re.findall(r'\=(.*)',flist1[i],re.S)[0]
+                pre2 = re.findall(r'(.*)\=',flist2[i],re.S)[0]
+                cons2 = re.findall(r'\=(.*)',flist2[i],re.S)[0]
+                x1.add(pre1)
+                x2.add(pre2)
+                y1.add(cons1)
+                y2.add(cons2)
+            if x1 == x2 and y1 == y2:
+                return True
+            else:
+                return False
+
+    def getFormulaLength(self,form):
+        result = re.findall(r'~\((.*)\)',form,re.S)[0]
+        list = result.split('&')
+        return len(list)
+
+    def getMaxLengthInList(self, flist):
+        max = 0
+        for f in flist:
+            if max < self.getFormulaLength(f):
+                max = self.getFormulaLength(f)
+        return max
+
+    def getSameLengthInList(self,flist,length):
+        list = []
+        for f in flist:
+            if self.getFormulaLength(f)==length:
+                list.append(f)
+        return list
+
+    def removeSamePatInList(self, flist):
+        mlen = self.getMaxLengthInList(flist)
+        totallist = []
+        for i in range(mlen+1):
+            if i ==0 or i ==1 :
+                continue
+            else:
+                nlist = self.getSameLengthInList(flist,i)
+                nonrlist = nlist
+                for j in nlist:
+                    for k in nlist[nlist.index(j)+1::]:
+                        if self.judgeExistSameFormula(j,k):
+                            nonrlist.remove(k)
+                totallist.extend(nonrlist)
+        return totallist
+
+    def normalize(self,form):
+        temp = re.findall(r'~\((.*)\)', form, re.S)[0]
+        list = temp.split('&')
+        count = 1
+        tlist = []
+        for i in list:
+            tlist.append(i.strip())
+        flist = []
+        for t in tlist:
+            if ' ' in t:
+                temp = re.findall(r'(\w*\s\w*)=', t, re.S)[0]
+                value = re.findall(r'=(.*)', t, re.S)[0]
+                if count == 1:
+                    temp = temp[:-1] + 'i' + '=' + value
+                else:
+                    temp = temp[:-1] + 'j' + '=' + value
+                count += 1
+                flist.append(temp)
+            else:
+                flist.append(t)
+        str1 = '~(' + ' & '.join(flist) + ')'
+        return str1
+
+    def singleFormEqual(self, form1, form2):
+        if ' ' in form1 and ' ' not in form2:
+            return False
+        elif ' ' in form2 and ' ' not in form1:
+            return False
+        else:
+            if ' ' in form1:
+                str1 = re.findall(r'(\w*)\s{1}(\w*)\=(\w*)', form1, re.S)[0]
+                str2 = re.findall(r'(\w*)\s{1}(\w*)\=(\w*)', form2, re.S)[0]
+                if str1[0] == str2[0] and str1[2] == str2[2]:
+                    return True
+                else:
+                    return False
+            else:
+                str1 = re.findall(r'(\w*)\=(\w*)', form1, re.S)[0]
+                str2 = re.findall(r'(\w*)\=(\w*)', form2, re.S)[0]
+                if str1[0] == str2[0] and str1[1] == str2[1]:
+                    return True
+                else:
+                    return False
+
+    def mutleFormEqual(self, form1, form2):
+        str1 = re.findall(r'\((.*?)\)', form1, re.S)[0]
+        str2 = re.findall(r'\((.*?)\)', form2, re.S)[0]
+        tlist1 = str1.split('&')
+        list1 = []
+        for t1 in tlist1:
+            list1.append(t1.strip())
+        tlist2 = str2.split('&')
+        list2 = []
+        for t2 in tlist2:
+            list2.append(t2.strip())
+        vlist1 = []
+        vlist2 = []
+        for f1 in list1:
+            if ' ' in f1:
+                value1 = re.findall(r'(\w*)\s{1}(\w*)\=(\w*)', f1, re.S)[0][2]
+            else:
+                value1 = re.findall(r'(\w*)\=(\w*)',f1,re.S)[0][1]
+            vlist1.append(value1)
+        for f2 in list2:
+            if ' ' in f2:
+                value2 = re.findall(r'(\w*)\s{1}(\w*)\=(\w*)', f2, re.S)[0][2]
+            else:
+                value2 = re.findall(r'(\w*)\=(\w*)',f2,re.S)[0][1]
+            vlist2.append(value2)
+        if len(list1) != len(list2):
+            return False
+        elif set(vlist1) != set(vlist2):
+            return False
+        else:
+            for i in vlist1:
+                if i not in vlist2:
+                    return False
+                else:
+                    index1 = vlist1.index(i)
+                    index2 = vlist2.index(i)
+                    if not self.singleFormEqual(list1[index1],list2[index2]):
+                        return False
+        return True
+
+    def changeFormulaIntoSmv(self, form1):
+        inner = re.findall(r'\((.*?)\)', form1, re.S)[0]
+        innerlist = inner.split('&')
+        smvlist = []
+        for i in innerlist:
+            before = re.findall(r'(.*)=', i.strip(), re.S)[0]
+            after = re.findall(r'=(.*)', i.strip(), re.S)[0].replace('True', 'TRUE').replace('False', 'FALSE')
+            if ' ' in before:
+                var = re.findall(r'(.*)\s', before, re.S)[0]
+                param = re.findall(r'\s(.*)', before, re.S)[0].replace('i','1').replace('j','2')
+                newbefore = var+'['+param+']'
+                smvlist.append('(' + newbefore +' = ' + after + ')')
+            else:
+                smvlist.append('(' + before + ' = ' + after + ')')
+        str = ' & '.join(smvlist)
+        return '(!('+str+'))'
+
+    def judgeTrueOfForm(self, form):
+        inner = re.findall(r'\((.*?)\)', form, re.S)[0]
+        innerlist = inner.split('&')
+        varDict = dict()
+        for i in innerlist:
+            before = re.findall(r'(.*)=', i.strip(), re.S)[0]
+            after = re.findall(r'=(.*)', i.strip(), re.S)[0]
+            if before not in varDict:
+                varDict[before] = after
+            else:
+                if varDict[before] != after:
+                    return True
+        return False
+
+    def subFormula(self, form1, form2):
+        str1 = re.findall(r'\((.*?)\)', form1, re.S)[0]
+        list1 = str1.split('&')
+        tlist = []
+        for l1 in list1:
+            tlist.append(l1.strip())
+        str2 = re.findall(r'\((.*?)\)', form2, re.S)[0]
+        list2 = str2.split('&')
+        tlist2 = []
+        for l2 in list2:
+            tlist2.append(l2.strip())
+        if set(tlist) < set(tlist2):
+            return 1
+        elif len(tlist) < len(tlist2):
+            templist = []
+            for i in set(tlist):
+                flag = False
+                for j in set(tlist2):
+                    if self.singleFormEqual(i, j):
+                        templist.append(j)
+                        flag = True
+                if not flag:
+                    return -1
+            if set(tlist) > set(templist):
+                return -1
+            if flag:
+                return 1
+        elif set(tlist) == set(tlist2):
+            return 0
+        else:
+            return -1
+
 
 if __name__ == '__main__':
     p = load_system('n_mutual.json')
-    # print(p.add_invariant_prop())
-    # for i,k in p.relation.items():
-    #     print(i,'->',k)
-    # print('===========================')
-    # for i in p.allinvs:
-        # print(i)
-    # p.search_invariant1()
-    # print(p.foundedinvs)
-    # print(p.relation['~(n i=C & n j=C)'])
-    # print(p.relation)
-    list = ['~(n i=C & n k=E & n j=C)', '~(n j=T & x=True & n k=E & n i=E)', '~(n k=C & n j=C & n i=E)']
-    # print(p.transform2onehot('~(n j=T & x=True)').astype(dtype=np.float32))
-    print(p.searchInvFromGivenFormula('~(n j=C)'))
-    # for i, k in p.relation.items():
-    #     for j in k:
-    #         print(j)
-
-# [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
-# action: 0
-# ~(n i=I & x=True) 3
-# ~(x=True)
-# nfs: ['~(n i=E & (True=True)', '~(n j=E & (True=True)']
\ No newline at end of file
+    str1 = '~(x=False & n j=exit & n i=exit)'
+    str2 = '~(x=True & n i=crit & n j=exit)'
+    str3 = '~(n i=exit & n j=crit)'
+    str4 = '~(n i=exit)'
+    str5 = '~(n i=exit & n i=idle & x=False)'
+    str6 = '~(n i=try & x=True & n j=idle)'
+    print(p.searchInvFromGivenFormula(str1))
+    # print(p.changeFormulaIntoSmv('~(n i=try & n j=crit & x=True)'))
+    print(p.judgeTrueOfForm('~(n j=try & n j=exit & n i=try & x=True)'))
+
diff --git a/Utils/__init__.py b/Utils/__init__.py
index f15c402..b911c0e 100644
--- a/Utils/__init__.py
+++ b/Utils/__init__.py
@@ -1,6 +1,5 @@
 from Utils.invHold import *
 from Utils.Paraverifier import *
 from Utils.parse import *
-from Utils.pdr import *
 from Utils.smt2 import *
 from Utils.type import *
\ No newline at end of file
diff --git a/Utils/__pycache__/Paraverifier.cpython-36.pyc b/Utils/__pycache__/Paraverifier.cpython-36.pyc
index 22ecdea..c156920 100644
Binary files a/Utils/__pycache__/Paraverifier.cpython-36.pyc and b/Utils/__pycache__/Paraverifier.cpython-36.pyc differ
diff --git a/Utils/__pycache__/__init__.cpython-36.pyc b/Utils/__pycache__/__init__.cpython-36.pyc
index a69f148..9b04a35 100644
Binary files a/Utils/__pycache__/__init__.cpython-36.pyc and b/Utils/__pycache__/__init__.cpython-36.pyc differ
diff --git a/Utils/__pycache__/invHold.cpython-36.pyc b/Utils/__pycache__/invHold.cpython-36.pyc
index 92cb941..5a36b22 100644
Binary files a/Utils/__pycache__/invHold.cpython-36.pyc and b/Utils/__pycache__/invHold.cpython-36.pyc differ
diff --git a/Utils/__pycache__/invHold.cpython-37.pyc b/Utils/__pycache__/invHold.cpython-37.pyc
index 2defcdd..d440876 100644
Binary files a/Utils/__pycache__/invHold.cpython-37.pyc and b/Utils/__pycache__/invHold.cpython-37.pyc differ
diff --git a/Utils/__pycache__/parse.cpython-36.pyc b/Utils/__pycache__/parse.cpython-36.pyc
index f84984e..55db1e3 100644
Binary files a/Utils/__pycache__/parse.cpython-36.pyc and b/Utils/__pycache__/parse.cpython-36.pyc differ
diff --git a/Utils/__pycache__/parse.cpython-37.pyc b/Utils/__pycache__/parse.cpython-37.pyc
index 83f36c3..f2e496b 100644
Binary files a/Utils/__pycache__/parse.cpython-37.pyc and b/Utils/__pycache__/parse.cpython-37.pyc differ
diff --git a/Utils/__pycache__/pdr.cpython-36.pyc b/Utils/__pycache__/pdr.cpython-36.pyc
deleted file mode 100644
index 7eb5b2c..0000000
Binary files a/Utils/__pycache__/pdr.cpython-36.pyc and /dev/null differ
diff --git a/Utils/__pycache__/pdr.cpython-37.pyc b/Utils/__pycache__/pdr.cpython-37.pyc
deleted file mode 100644
index 5915072..0000000
Binary files a/Utils/__pycache__/pdr.cpython-37.pyc and /dev/null differ
diff --git a/Utils/__pycache__/smt2.cpython-36.pyc b/Utils/__pycache__/smt2.cpython-36.pyc
index 7df7713..816a200 100644
Binary files a/Utils/__pycache__/smt2.cpython-36.pyc and b/Utils/__pycache__/smt2.cpython-36.pyc differ
diff --git a/Utils/__pycache__/smt2.cpython-37.pyc b/Utils/__pycache__/smt2.cpython-37.pyc
index 6c6e745..a3a3840 100644
Binary files a/Utils/__pycache__/smt2.cpython-37.pyc and b/Utils/__pycache__/smt2.cpython-37.pyc differ
diff --git a/Utils/__pycache__/type.cpython-36.pyc b/Utils/__pycache__/type.cpython-36.pyc
index 1548bfd..fec40ce 100644
Binary files a/Utils/__pycache__/type.cpython-36.pyc and b/Utils/__pycache__/type.cpython-36.pyc differ
diff --git a/Utils/__pycache__/type.cpython-37.pyc b/Utils/__pycache__/type.cpython-37.pyc
index bb53719..a5c320b 100644
Binary files a/Utils/__pycache__/type.cpython-37.pyc and b/Utils/__pycache__/type.cpython-37.pyc differ
diff --git a/Utils/logger.py b/Utils/logger.py
index e69de29..526b340 100644
--- a/Utils/logger.py
+++ b/Utils/logger.py
@@ -0,0 +1,44 @@
+import os
+import logging
+from logging import getLogger, StreamHandler, FileHandler, Formatter
+import datetime
+
+
+def initialize_logger(logging_level=logging.INFO, output_dir="/Logs", filename=None, save_log=True):
+    logger = getLogger()
+    logger.setLevel(logging_level)
+
+    handler_format = Formatter(
+        '%(asctime)s.%(msecs)03d [%(levelname)s] (%(filename)s:%(lineno)s) %(message)s',
+        "%H:%M:%S")  # If you want to show date, add %Y-%m-%d
+    stream_handler = StreamHandler()
+    stream_handler.setLevel(logging_level)
+    stream_handler.setFormatter(handler_format)
+
+    if save_log:
+        if filename is not None:
+            filename = filename
+        else:
+            if not os.path.exists(os.path.dirname(os.getcwd()) + '/Logs/'):
+                os.mkdir(os.path.dirname(os.getcwd()) + '/Logs/')
+            filename = os.path.join(
+                os.path.dirname(os.getcwd()) + '/Logs/', datetime.datetime.now().strftime("%Y%m%dT%H%M%S.%f") + '.log')
+
+        file_handler = FileHandler(filename, 'a')
+        file_handler.setLevel(logging.DEBUG)
+        file_handler.setFormatter(handler_format)
+
+    if len(logger.handlers) == 0:
+        logger.addHandler(stream_handler)
+        if save_log:
+            logger.addHandler(file_handler)
+    else:
+        # Overwrite logging setting
+        logger.handlers[0] = stream_handler
+        if save_log:
+            logger.handlers[1].close()
+            logger.handlers[1] = file_handler
+
+    logger.propagate = False
+
+    return logger
diff --git a/Utils/mutual.m b/Utils/mutual.m
deleted file mode 100644
index e9a026d..0000000
--- a/Utils/mutual.m
+++ /dev/null
@@ -1,39 +0,0 @@
-const clientNUMS : 5;
-type state : enum{I, T, C, E};
-
-     client: 1..clientNUMS;
-
-var n : array [client] of state;
-
-    x : boolean;
-
-ruleset i : client do
-rule "Try" n[i] = I ==> begin
-      n[i] := T;end;
-
-rule "Crit"
-      n[i] = T& x = true ==>begin
-      n[i] := C; x := false; end;
-
-rule "Exit"
-      n[i] = C ==>begin
-      n[i] := E;end;
-
-
-rule "Idle"
-      n[i] = E ==> begin n[i] := I;
-      x := true;end;
-endruleset;
-
-startstate
-begin
- for i: client do
-    n[i] := I;
-    x := true;
-  endfor;
-endstartstate;
-
-ruleset i:client; j: client do
-invariant "coherence"
- ! (n[i] = C & n[j] = C)
-endruleset;
diff --git a/Utils/parse.py b/Utils/parse.py
index cce8508..5ee18ee 100644
--- a/Utils/parse.py
+++ b/Utils/parse.py
@@ -83,23 +83,17 @@ class ParaverifierTransformer(Transformer):
         return Vardef(arn, args, tyn)
 
     def var(self, *args):
-        # print('var:',args[0])
         return Var(args[0])
 
     def var1(self, *args):
-        # print('var1:',args)
         return EVar(args[0], args[1])
 
     def evar(self, *args):
-        # print('evar:',args)
         return args[0]
 
     def econst(self, context):
         return EConst(context)
 
-    # def eword(self,*args):
-    #     return EVar(args[0],args[1])
-
     def eparamr(self, p):
         return EParamr(p)
 
@@ -119,7 +113,6 @@ class ParaverifierTransformer(Transformer):
         return FUip(e1, e2)
 
     def feqn(self, *args):
-        # print(args)
         return FEqn(args[0], args[1])
 
     def fneg(self, f):
@@ -147,12 +140,9 @@ class ParaverifierTransformer(Transformer):
         return SParallel(args)
 
     def rule(self, *args):
-        # print(args)
-        # args1=str(args[0])
         return Rule(args[0], args[2], args[3], args[1])
 
     def prop(self, *args):
-        # print(args)
         return Prop(args[1], args[0])
 
     def startstate(self, *args):
@@ -171,15 +161,12 @@ def get_parser_for(start):
 
 const_parser = get_parser_for('const')
 vars_parser = get_parser_for("var")
-# param_parse = get_parser_for('paramr')
 exp_parser = get_parser_for('expression')
 state_parser = get_parser_for('state')
 form_parser = get_parser_for('formula')
 statement_parser = get_parser_for('statement')
 rule_parser = get_parser_for('rule')
 prop_parser = get_parser_for('prop')
-# rule_parser = get_parser_for("rule")
-# prop_parser = get_parser_for("prop")
 init_parser = get_parser_for('init')
 
 
diff --git a/Utils/smt2.py b/Utils/smt2.py
index b9899e2..99e1be3 100644
--- a/Utils/smt2.py
+++ b/Utils/smt2.py
@@ -3,7 +3,7 @@
 
 import json
 import re
-from z3 import Solver
+from z3 import *
 
 
 class SMT2(object):
@@ -127,12 +127,12 @@ class SMT2(object):
 
 
 if __name__ == '__main__':
-    smt2 = SMT2('../Protocol/n_mutual.json')
+    smt2 = SMT2('../Protocol/n_mutual1.json')
     # print(smt2.check("~(x=True & n j=T)"))
     # print(smt2.check('~(n i =C)'))
-    # s= Solver()
-    # s.from_string("(declare-datatypes () ((state I T C E))) (declare-const n (Array Int state)) (declare-const x Bool) (declare-const i Int) (declare-const j Int) (assert (and (= (select n i ) C) (= (select n j) C) (not (= i j)) ))")
-    # print(s.check())
+    s= Solver()
+    s.from_string("(declare-datatypes () ((state I T C E))) (declare-const n (Array Int state)) (declare-const x Bool) (declare-const i Int) (declare-const j Int) (assert (and (= (select n i ) C) (= (select n j) C) (not (= i j)) ))")
+    print(s.check())
     # print(s.model())
     # print(smt2.check("~(n[i]=T & x=True & C=C & n[j]=C)"))
     # print(smt2.check("~(x=True & n[j]=T)"))
